1. В ScriptLexer/ServerMsgLexer заместо die() кидаем
(Script|ServerMsg)LexerFailedException. Там, где ловим, делаем следующее:
----
ex.print();
printf("Program paused (syscall pause()) for attaching debugger.\n"
       "Attach GNU Debugger:      `gdb %s %d`\n."
       "Make coredump file:       <Ctrl+/>.\n"
       "Simply terminate program: <Ctrl+C>.\n",
    argv[0], getpid());
----

2. В CharQueue: добавление в конец очереди даже если что-то уже есть. Подумать
как при таком подходе отдавать в нужный момент EOF.

3. int -> bool.

4. По языку:
4.1. Тип player_pointer.
4.2. Данные представляются списками (или отображениями из player_pointer в
int/double).
4.3. Комментарии: // до конца строки, если не в двойных кавычках. Если встречен
один '/', то LEX_ERROR. Комментарий должен являться разделителем (как пробел).

5. В ServerMsgLexer для ответов на "status" можно выбирать все числа подряд,
отделённые ' ' или '\n' и уже их анализировать. Большая гибкость, можно
получить больше информации.

6. Таблица констант. Числовые и строковые. Для одинаковых — одна запись.

7. Составлять в каждом методе парсера свою цепочку элементов ПОЛИЗа, а потом
соединять их в вышестоящих методах. Этот подход позволяет легко переставлять
достаточно сложные цепочки в нужном порядке. Решает проблему с «set $b $b»
(проверяем оперделеная ли переменная и определяем её непосредственно при
выполнении). Решает проблему с меткой и тем, что элемент, на который она должна
указывать, ещё не построен при её анализе.
