1. В ScriptLexer/ServerMsgLexer заместо die() кидаем
(Script|ServerMsg)LexerFailedException. Там, где ловим, делаем следующее:
----
ex.print();
printf("Program paused (syscall pause()) for attaching debugger.\n"
       "Attach GNU Debugger:      `gdb %s %d`\n."
       "Make coredump file:       <Ctrl+/>.\n"
       "Simply terminate program: <Ctrl+C>.\n",
    argv[0], getpid());
----
Если делать там, где ловим exception, то стек уже свёрнут. А там, где произошла
ошибка надо просто кидать exception, а не останавливать программу.

2. В CharQueue: добавление в конец очереди даже если что-то уже есть. Подумать
как при таком подходе отдавать в нужный момент EOF. Впочем, это не необходимо.
Нужно подумать, сохранять указатель с CharQueue или копировать строку.

3. Возвращаемые значения: int -> bool; там, где семантика соответствует.

4. По языку:
4.1. Тип player_pointer.
4.2. Данные представляются списками (или отображениями из player_pointer в
int/double).

player_pointer my_player;
player_pointer players_list[];
set my_player, ?get_my_player();
set players_list, get_players_list();

4.3. Комментарии: // до конца строки, если не в двойных кавычках. Если встречен
один '/', то LEX_ERROR. Комментарий должен являться разделителем (как пробел).

5. В ServerMsgLexer для ответов на "status" можно выбирать все числа подряд,
отделённые ' ' или '\n' и уже их анализировать. Большая гибкость, можно
получить больше информации.

6. Проверить на утечки памяти, разобраться, где строки копировать, где хранить
константный указатель, где — нет.

7. Иерархическая система сообщений для ServerMsgLexer.

8. Отнаследовать все исключения от Exception с description, постараться
минимизировать количество кода.

9. Дополнительная проверка корректности скрипта перед выполнением (evaluate):
   tables.allStringsDefined();
   tables.allLabelsDefined();

10. Метка первой лексемой.
